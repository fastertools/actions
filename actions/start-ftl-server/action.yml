name: 'Start FTL Server'
description: 'Start FTL server in background with health checks and process management'
author: 'FasterTools'
branding:
  icon: 'play-circle'
  color: 'green'

inputs:
  health-check-timeout:
    description: 'Maximum time to wait for server health check (seconds)'
    required: false
    default: '30'
  
  build:
    description: 'Build before starting server'
    required: false
    default: 'false'
  
  watch:
    description: 'Watch files and rebuild automatically'
    required: false
    default: 'false'
    
  clear:
    description: 'Clear screen on rebuild (only with --watch)'
    required: false
    default: 'false'
    
  log-dir:
    description: 'Directory for component logs (default: .ftl/logs)'
    required: false
    default: ''
    
  port:
    description: 'Port for FTL server (default: auto-detect)'
    required: false
    default: '3000'
  
  config-file:
    description: 'Path to FTL configuration file'
    required: false
    default: ''
    
  background:
    description: 'Run server in background (true) or foreground (false)'
    required: false
    default: 'true'

outputs:
  server-pid:
    description: 'Process ID of the running FTL server'
    value: ${{ steps.start.outputs.server-pid }}
  
  server-url:
    description: 'URL where the FTL server is accessible'
    value: ${{ steps.start.outputs.server-url }}
    
  health-check-url:
    description: 'Health check endpoint URL'
    value: ${{ steps.start.outputs.health-check-url }}

runs:
  using: 'composite'
  steps:
    - name: Input Validation
      shell: bash
      run: |
        set -euo pipefail
        
        # Global error trap
        trap 'echo "ERROR: Input validation failed at line $LINENO. Exit code: $?" >&2' ERR
        
        # Validate numeric inputs
        timeout="${{ inputs.health-check-timeout }}"
        if ! [[ "$timeout" =~ ^[0-9]+$ ]] || [ "$timeout" -lt 1 ] || [ "$timeout" -gt 300 ]; then
          echo "ERROR: health-check-timeout must be a number between 1 and 300, got: '$timeout'" >&2
          exit 1
        fi
        
        # Validate port if provided
        port="${{ inputs.port }}"
        if [[ -n "$port" ]]; then
          if ! [[ "$port" =~ ^[0-9]+$ ]] || [ "$port" -lt 1024 ] || [ "$port" -gt 65535 ]; then
            echo "ERROR: port must be a number between 1024 and 65535, got: '$port'" >&2
            exit 1
          fi
        fi
        
        # Validate boolean inputs
        for input_var in "build:${{ inputs.build }}" "watch:${{ inputs.watch }}" "clear:${{ inputs.clear }}"; do
          name=${input_var%:*}
          value=${input_var#*:}
          case "$value" in
            "true"|"false") ;;
            *) echo "ERROR: $name must be 'true' or 'false', got: '$value'" >&2; exit 1 ;;
          esac
        done
        
        # Validate boolean
        background="${{ inputs.background }}"
        case "$background" in
          "true"|"false") ;;
          *) echo "ERROR: background must be 'true' or 'false', got: '$background'" >&2; exit 1 ;;
        esac
        
        echo "‚úÖ Input validation passed"

    - name: Verify FTL CLI
      shell: bash
      run: |
        set -euo pipefail
        
        echo "::group::üîç Verifying FTL CLI Installation"
        
        # Check if ftl command is available
        if ! command -v ftl >/dev/null 2>&1; then
          echo "ERROR: FTL CLI not found. Please run the 'fastertools/actions/actions/setup-ftl' action first." >&2
          exit 1
        fi
        
        ftl_version=""
        if ftl_version=$(ftl --version 2>&1); then
          echo "‚úÖ FTL CLI found: $ftl_version"
        else
          echo "ERROR: FTL CLI found but --version failed: $ftl_version" >&2
          exit 1
        fi
        
        echo "::endgroup::"

    - name: Start FTL Server
      id: start
      shell: bash
      run: |
        set -euo pipefail
        
        # Global error trap
        trap 'echo "ERROR: Server start failed at line $LINENO. Exit code: $?" >&2' ERR
        
        # Structured logging functions
        start_group() {
          echo "::group::$1"
        }
        
        end_group() {
          echo "::endgroup::"
        }
        
        log_info() {
          echo "‚ÑπÔ∏è $1"
        }
        
        log_success() {
          echo "‚úÖ $1"
        }
        
        log_warning() {
          echo "‚ö†Ô∏è $1"
        }
        
        log_step() {
          echo "üìù Step: $1"
        }
        
        start_group "üöÄ Starting FTL Server"
        
        # Build ftl up command
        FTL_CMD="ftl up"
        
        # Add port if specified
        if [[ -n "${{ inputs.port }}" ]]; then
          FTL_CMD="$FTL_CMD --port=${{ inputs.port }}"
        fi
        
        # Add build flag if specified
        if [[ "${{ inputs.build }}" == "true" ]]; then
          FTL_CMD="$FTL_CMD --build"
        fi
        
        # Add watch flag if specified
        if [[ "${{ inputs.watch }}" == "true" ]]; then
          FTL_CMD="$FTL_CMD --watch"
        fi
        
        # Add clear flag if specified (only with watch)
        if [[ "${{ inputs.clear }}" == "true" && "${{ inputs.watch }}" == "true" ]]; then
          FTL_CMD="$FTL_CMD --clear"
        elif [[ "${{ inputs.clear }}" == "true" ]]; then
          log_warning "clear flag ignored (only works with --watch)"
        fi
        
        # Add log directory if specified
        if [[ -n "${{ inputs.log-dir }}" ]]; then
          FTL_CMD="$FTL_CMD --log-dir=${{ inputs.log-dir }}"
        fi
        
        # Add config file if specified
        if [[ -n "${{ inputs.config-file }}" ]]; then
          if [[ ! -f "${{ inputs.config-file }}" ]]; then
            echo "ERROR: Configuration file not found: ${{ inputs.config-file }}" >&2
            exit 1
          fi
          FTL_CMD="$FTL_CMD ${{ inputs.config-file }}"  # PATH argument, not --config flag
        fi
        
        log_info "Server command: $FTL_CMD"
        
        if [[ "${{ inputs.background }}" == "true" ]]; then
          # Background mode with process management
          log_step "Starting server in background"
          
          # Create log file for server output
          SERVER_LOG_FILE="$HOME/ftl-server.log"
          log_info "Server logs will be written to: $SERVER_LOG_FILE"
          
          # Start server in background and capture PID
          $FTL_CMD > "$SERVER_LOG_FILE" 2>&1 &
          SERVER_PID=$!
          
          log_success "Server started with PID: $SERVER_PID"
          echo "server-pid=$SERVER_PID" >> "$GITHUB_OUTPUT"
          
          # Save PID for potential cleanup
          echo "$SERVER_PID" > "$HOME/ftl-server.pid"
          
          # Wait a moment for server to initialize
          sleep 2
          
          # Check if process is still running
          if ! kill -0 "$SERVER_PID" 2>/dev/null; then
            log_warning "Server process died immediately, checking logs..."
            if [[ -f "$SERVER_LOG_FILE" ]]; then
              echo "::group::üîç Server Startup Logs"
              cat "$SERVER_LOG_FILE"
              echo "::endgroup::"
            fi
            echo "ERROR: FTL server failed to start" >&2
            exit 1
          fi
          
          log_success "Server process is running (PID: $SERVER_PID)"
          
        else
          # Foreground mode (for debugging or simple cases)
          log_step "Starting server in foreground"
          log_warning "Server will run in foreground - workflow will wait here"
          
          # Note: In foreground mode, the step will not complete until server stops
          exec $FTL_CMD
        fi
        
        end_group

    - name: Health Check
      if: inputs.background == 'true'
      shell: bash
      run: |
        set -euo pipefail
        
        # Global error trap
        trap 'echo "ERROR: Health check failed at line $LINENO. Exit code: $?" >&2' ERR
        
        echo "::group::üè• Server Health Check"
        
        # Check if jq is available for MCP response parsing
        if ! command -v jq >/dev/null 2>&1; then
          echo "ERROR: jq is required for MCP health checks but not installed" >&2
          exit 1
        fi
        
        SERVER_PID=$(cat "$HOME/ftl-server.pid" 2>/dev/null || echo "")
        if [[ -z "$SERVER_PID" ]]; then
          echo "ERROR: Could not find server PID file" >&2
          exit 1
        fi
        
        # Determine server URL (basic detection)
        # Note: This is a simplified approach - real implementation would parse ftl output
        if [[ -n "${{ inputs.port }}" ]]; then
          SERVER_URL="http://localhost:${{ inputs.port }}"
        else
          SERVER_URL="http://localhost:3000"  # FTL default port
        fi
        
        # FTL server uses MCP (Model Context Protocol) - use tools/list for health check
        MCP_URL="${SERVER_URL}/mcp"
        HEALTH_URL="$MCP_URL"
        
        echo "server-url=$SERVER_URL" >> "$GITHUB_OUTPUT"
        echo "health-check-url=$HEALTH_URL" >> "$GITHUB_OUTPUT"
        
        echo "‚ÑπÔ∏è Server URL: $SERVER_URL"
        echo "‚ÑπÔ∏è Health check URL: $HEALTH_URL"
        echo "‚ÑπÔ∏è Health check timeout: ${{ inputs.health-check-timeout }} seconds"
        
        # Health check with timeout
        timeout_seconds="${{ inputs.health-check-timeout }}"
        attempt=1
        max_attempts=10
        sleep_interval=$((timeout_seconds / max_attempts))
        
        # Ensure minimum sleep interval
        if [[ $sleep_interval -lt 1 ]]; then
          sleep_interval=1
          max_attempts=$timeout_seconds
        fi
        
        echo "üìù Step: Waiting for server to be ready (max ${timeout_seconds}s, checking every ${sleep_interval}s)"
        
        while [[ $attempt -le $max_attempts ]]; do
          echo "üîç Health check attempt $attempt of $max_attempts"
          
          # Check if process is still running
          if ! kill -0 "$SERVER_PID" 2>/dev/null; then
            echo "ERROR: Server process died (PID: $SERVER_PID)" >&2
            if [[ -f "$HOME/ftl-server.log" ]]; then
              echo "::group::üìã Server Logs"
              cat "$HOME/ftl-server.log"
              echo "::endgroup::"
            fi
            exit 1
          fi
          
          # Try MCP tools/list command for health check
          mcp_request='{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}'
          
          echo "üîç Testing MCP endpoint: $HEALTH_URL"
          echo "üîç MCP request: $mcp_request"
          
          # Store curl response for debugging
          mcp_response=""
          http_status=""
          if mcp_response=$(curl -w "HTTP_STATUS:%{http_code}" -s --connect-timeout 5 --max-time 10 \
               -H "Content-Type: application/json" \
               -X POST \
               -d "$mcp_request" \
               "$HEALTH_URL" 2>&1); then
            
            # Extract HTTP status and response body
            http_status=$(echo "$mcp_response" | grep -o 'HTTP_STATUS:[0-9]*' | cut -d: -f2)
            response_body=$(echo "$mcp_response" | sed 's/HTTP_STATUS:[0-9]*$//')
            
            echo "üîç HTTP Status: $http_status"
            echo "üîç MCP Response: $response_body"
            
            # Check if we got a valid MCP response
            if echo "$response_body" | jq -e '.result.tools' >/dev/null 2>&1; then
              echo "‚úÖ MCP health check passed (tools/list responded correctly)!"
              echo "‚úÖ FTL server is ready at: $SERVER_URL"
              break
            elif echo "$response_body" | jq -e '.error' >/dev/null 2>&1; then
              echo "‚ö†Ô∏è MCP endpoint responded but with error: $(echo "$response_body" | jq -r '.error.message // .error')"
            else
              echo "‚ö†Ô∏è MCP endpoint responded but not valid MCP format"
            fi
          else
            echo "üîç MCP curl failed: $mcp_response"
          fi
          
          # Fallback: basic HTTP check if MCP endpoint not ready yet
          echo "üîç Testing basic HTTP: $SERVER_URL"
          if basic_response=$(curl -w "HTTP_STATUS:%{http_code}" -s --connect-timeout 5 --max-time 10 "$SERVER_URL" 2>&1); then
            basic_status=$(echo "$basic_response" | grep -o 'HTTP_STATUS:[0-9]*' | cut -d: -f2)
            basic_body=$(echo "$basic_response" | sed 's/HTTP_STATUS:[0-9]*$//')
            echo "üîç Basic HTTP Status: $basic_status"
            echo "üîç Basic HTTP Response: ${basic_body:0:200}$([ ${#basic_body} -gt 200 ] && echo '...')"
            echo "‚è≥ Server responding but MCP not ready yet..."
          else
            echo "üîç Basic HTTP also failed"
          fi
          
          if [[ $attempt -eq $max_attempts ]]; then
            echo "ERROR: MCP health check failed after ${timeout_seconds}s" >&2
            echo "üîç Server process status: $(ps -p "$SERVER_PID" -o pid,ppid,stat,comm 2>/dev/null || echo 'not found')"
            echo "üîç Final check - what endpoints are available:"
            
            # Try to discover what endpoints exist
            for endpoint in "/" "/health" "/mcp" "/api" "/tools/list"; do
              test_url="${SERVER_URL}${endpoint}"
              echo "  Testing: $test_url"
              if response=$(curl -w "HTTP:%{http_code}" -s --connect-timeout 2 --max-time 5 "$test_url" 2>&1); then
                status=$(echo "$response" | grep -o 'HTTP:[0-9]*' | cut -d: -f2)
                body=$(echo "$response" | sed 's/HTTP:[0-9]*$//')
                echo "    Status: $status, Body: ${body:0:100}$([ ${#body} -gt 100 ] && echo '...')"
              else
                echo "    Failed: $response"
              fi
            done
            
            if [[ -f "$HOME/ftl-server.log" ]]; then
              echo "::group::üìã Recent Server Logs"
              tail -50 "$HOME/ftl-server.log"
              echo "::endgroup::"
            fi
            exit 1
          else
            echo "‚è≥ Server not ready yet, waiting ${sleep_interval}s..."
            sleep $sleep_interval
          fi
          
          attempt=$((attempt + 1))
        done
        
        echo "::endgroup::"

    - name: Server Summary
      if: inputs.background == 'true'
      shell: bash
      run: |
        set -euo pipefail
        
        echo "::group::üìã FTL Server Status"
        
        SERVER_PID=$(cat "$HOME/ftl-server.pid" 2>/dev/null || echo "unknown")
        SERVER_URL="${{ steps.start.outputs.server-url }}"
        
        echo "‚úÖ FTL Server Status: Running"
        echo "‚úÖ Process ID: $SERVER_PID"
        echo "‚úÖ Server URL: $SERVER_URL"
        echo "‚úÖ Build Mode: ${{ inputs.build }}"
        echo "‚úÖ Watch Mode: ${{ inputs.watch }}"
        
        if [[ -n "${{ inputs.port }}" ]]; then
          echo "‚úÖ Port: ${{ inputs.port }}"
        else
          echo "‚úÖ Port: auto-detected"
        fi
        
        if [[ -n "${{ inputs.log-dir }}" ]]; then
          echo "‚úÖ Log Directory: ${{ inputs.log-dir }}"
        else
          echo "‚úÖ Log Directory: .ftl/logs (default)"
        fi
        
        echo ""
        echo "üîß Server Management:"
        echo "  ‚Ä¢ View logs: cat ~/ftl-server.log"
        echo "  ‚Ä¢ Check process: ps -p $SERVER_PID"
        echo "  ‚Ä¢ Stop server: kill $SERVER_PID"
        echo ""
        echo "üí° Note: Server will automatically stop when workflow ends"
        
        echo "::endgroup::"
        
        # Generate GitHub Actions step summary
        cat >> $GITHUB_STEP_SUMMARY << EOF
        ## üöÄ FTL Server Started
        
        ‚úÖ **Status**: Running in background  
        ‚úÖ **Process ID**: \`$SERVER_PID\`  
        ‚úÖ **Server URL**: [\`$SERVER_URL\`]($SERVER_URL)  
        ‚úÖ **Build Mode**: ${{ inputs.build }}  
        ‚úÖ **Watch Mode**: ${{ inputs.watch }}  
        
        ### üîß Server Management
        
        **View server logs:**
        \`\`\`bash
        cat ~/ftl-server.log
        \`\`\`
        
        ---
        *Server will continue running for subsequent workflow steps*
        EOF